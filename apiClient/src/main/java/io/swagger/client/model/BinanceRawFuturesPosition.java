/*
 * Core API v2.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import android.os.Parcel;
import android.os.Parcelable;

import com.google.gson.annotations.SerializedName;

import java.util.Objects;

import io.swagger.v3.oas.annotations.media.Schema;

/**
 * BinanceRawFuturesPosition
 */


public class BinanceRawFuturesPosition implements Parcelable
{
	public static final Parcelable.Creator<BinanceRawFuturesPosition> CREATOR = new Parcelable.Creator<BinanceRawFuturesPosition>()
	{
		public BinanceRawFuturesPosition createFromParcel(Parcel in) {
			return new BinanceRawFuturesPosition(in);
		}

		public BinanceRawFuturesPosition[] newArray(int size) {
			return new BinanceRawFuturesPosition[size];
		}
	};

	@SerializedName("entryPrice")
	private Double entryPrice = null;

	@SerializedName("marginType")
	private BinanceFuturesMarginType marginType = null;

	@SerializedName("isAutoAddMargin")
	private Boolean isAutoAddMargin = null;

	@SerializedName("positionAmount")
	private Double positionAmount = null;

	@SerializedName("isolatedMargin")
	private Double isolatedMargin = null;

	@SerializedName("leverage")
	private Integer leverage = null;

	@SerializedName("liquidationPrice")
	private Double liquidationPrice = null;

	@SerializedName("markPrice")
	private Double markPrice = null;

	@SerializedName("maxNotionalValue")
	private Double maxNotionalValue = null;

	@SerializedName("symbol")
	private String symbol = null;

	@SerializedName("unrealizedProfit")
	private Double unrealizedProfit = null;

	@SerializedName("positionSide")
	private BinancePositionSide positionSide = null;

	public BinanceRawFuturesPosition() {
	}

	BinanceRawFuturesPosition(Parcel in) {
		entryPrice = (Double) in.readValue(null);
		marginType = (BinanceFuturesMarginType) in.readValue(BinanceFuturesMarginType.class.getClassLoader());
		isAutoAddMargin = (Boolean) in.readValue(null);
		positionAmount = (Double) in.readValue(null);
		isolatedMargin = (Double) in.readValue(null);
		leverage = (Integer) in.readValue(null);
		liquidationPrice = (Double) in.readValue(null);
		markPrice = (Double) in.readValue(null);
		maxNotionalValue = (Double) in.readValue(null);
		symbol = (String) in.readValue(null);
		unrealizedProfit = (Double) in.readValue(null);
		positionSide = (BinancePositionSide) in.readValue(BinancePositionSide.class.getClassLoader());
	}

	public BinanceRawFuturesPosition entryPrice(Double entryPrice) {
		this.entryPrice = entryPrice;
		return this;
	}

	/**
	 * Get entryPrice
	 *
	 * @return entryPrice
	 **/
	@Schema(description = "")
	public Double getEntryPrice() {
		return entryPrice;
	}

	public void setEntryPrice(Double entryPrice) {
		this.entryPrice = entryPrice;
	}

	public BinanceRawFuturesPosition marginType(BinanceFuturesMarginType marginType) {
		this.marginType = marginType;
		return this;
	}

	/**
	 * Get marginType
	 *
	 * @return marginType
	 **/
	@Schema(description = "")
	public BinanceFuturesMarginType getMarginType() {
		return marginType;
	}

	public void setMarginType(BinanceFuturesMarginType marginType) {
		this.marginType = marginType;
	}

	public BinanceRawFuturesPosition isAutoAddMargin(Boolean isAutoAddMargin) {
		this.isAutoAddMargin = isAutoAddMargin;
		return this;
	}

	/**
	 * Get isAutoAddMargin
	 *
	 * @return isAutoAddMargin
	 **/
	@Schema(description = "")
	public Boolean isIsAutoAddMargin() {
		return isAutoAddMargin;
	}

	public void setIsAutoAddMargin(Boolean isAutoAddMargin) {
		this.isAutoAddMargin = isAutoAddMargin;
	}

	public BinanceRawFuturesPosition positionAmount(Double positionAmount) {
		this.positionAmount = positionAmount;
		return this;
	}

	/**
	 * Get positionAmount
	 *
	 * @return positionAmount
	 **/
	@Schema(description = "")
	public Double getPositionAmount() {
		return positionAmount;
	}

	public void setPositionAmount(Double positionAmount) {
		this.positionAmount = positionAmount;
	}

	public BinanceRawFuturesPosition isolatedMargin(Double isolatedMargin) {
		this.isolatedMargin = isolatedMargin;
		return this;
	}

	/**
	 * Get isolatedMargin
	 *
	 * @return isolatedMargin
	 **/
	@Schema(description = "")
	public Double getIsolatedMargin() {
		return isolatedMargin;
	}

	public void setIsolatedMargin(Double isolatedMargin) {
		this.isolatedMargin = isolatedMargin;
	}

	public BinanceRawFuturesPosition leverage(Integer leverage) {
		this.leverage = leverage;
		return this;
	}

	/**
	 * Get leverage
	 *
	 * @return leverage
	 **/
	@Schema(description = "")
	public Integer getLeverage() {
		return leverage;
	}

	public void setLeverage(Integer leverage) {
		this.leverage = leverage;
	}

	public BinanceRawFuturesPosition liquidationPrice(Double liquidationPrice) {
		this.liquidationPrice = liquidationPrice;
		return this;
	}

	/**
	 * Get liquidationPrice
	 *
	 * @return liquidationPrice
	 **/
	@Schema(description = "")
	public Double getLiquidationPrice() {
		return liquidationPrice;
	}

	public void setLiquidationPrice(Double liquidationPrice) {
		this.liquidationPrice = liquidationPrice;
	}

	public BinanceRawFuturesPosition markPrice(Double markPrice) {
		this.markPrice = markPrice;
		return this;
	}

	/**
	 * Get markPrice
	 *
	 * @return markPrice
	 **/
	@Schema(description = "")
	public Double getMarkPrice() {
		return markPrice;
	}

	public void setMarkPrice(Double markPrice) {
		this.markPrice = markPrice;
	}

	public BinanceRawFuturesPosition maxNotionalValue(Double maxNotionalValue) {
		this.maxNotionalValue = maxNotionalValue;
		return this;
	}

	/**
	 * Get maxNotionalValue
	 *
	 * @return maxNotionalValue
	 **/
	@Schema(description = "")
	public Double getMaxNotionalValue() {
		return maxNotionalValue;
	}

	public void setMaxNotionalValue(Double maxNotionalValue) {
		this.maxNotionalValue = maxNotionalValue;
	}

	public BinanceRawFuturesPosition symbol(String symbol) {
		this.symbol = symbol;
		return this;
	}

	/**
	 * Get symbol
	 *
	 * @return symbol
	 **/
	@Schema(description = "")
	public String getSymbol() {
		return symbol;
	}

	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}

	public BinanceRawFuturesPosition unrealizedProfit(Double unrealizedProfit) {
		this.unrealizedProfit = unrealizedProfit;
		return this;
	}

	/**
	 * Get unrealizedProfit
	 *
	 * @return unrealizedProfit
	 **/
	@Schema(description = "")
	public Double getUnrealizedProfit() {
		return unrealizedProfit;
	}

	public void setUnrealizedProfit(Double unrealizedProfit) {
		this.unrealizedProfit = unrealizedProfit;
	}

	public BinanceRawFuturesPosition positionSide(BinancePositionSide positionSide) {
		this.positionSide = positionSide;
		return this;
	}

	/**
	 * Get positionSide
	 *
	 * @return positionSide
	 **/
	@Schema(description = "")
	public BinancePositionSide getPositionSide() {
		return positionSide;
	}

	public void setPositionSide(BinancePositionSide positionSide) {
		this.positionSide = positionSide;
	}

	@Override
	public boolean equals(java.lang.Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		BinanceRawFuturesPosition binanceRawFuturesPosition = (BinanceRawFuturesPosition) o;
		return Objects.equals(this.entryPrice, binanceRawFuturesPosition.entryPrice) &&
				Objects.equals(this.marginType, binanceRawFuturesPosition.marginType) &&
				Objects.equals(this.isAutoAddMargin, binanceRawFuturesPosition.isAutoAddMargin) &&
				Objects.equals(this.positionAmount, binanceRawFuturesPosition.positionAmount) &&
				Objects.equals(this.isolatedMargin, binanceRawFuturesPosition.isolatedMargin) &&
				Objects.equals(this.leverage, binanceRawFuturesPosition.leverage) &&
				Objects.equals(this.liquidationPrice, binanceRawFuturesPosition.liquidationPrice) &&
				Objects.equals(this.markPrice, binanceRawFuturesPosition.markPrice) &&
				Objects.equals(this.maxNotionalValue, binanceRawFuturesPosition.maxNotionalValue) &&
				Objects.equals(this.symbol, binanceRawFuturesPosition.symbol) &&
				Objects.equals(this.unrealizedProfit, binanceRawFuturesPosition.unrealizedProfit) &&
				Objects.equals(this.positionSide, binanceRawFuturesPosition.positionSide);
	}

	@Override
	public int hashCode() {
		return Objects.hash(entryPrice, marginType, isAutoAddMargin, positionAmount, isolatedMargin, leverage, liquidationPrice, markPrice, maxNotionalValue, symbol, unrealizedProfit, positionSide);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class BinanceRawFuturesPosition {\n");

		sb.append("    entryPrice: ").append(toIndentedString(entryPrice)).append("\n");
		sb.append("    marginType: ").append(toIndentedString(marginType)).append("\n");
		sb.append("    isAutoAddMargin: ").append(toIndentedString(isAutoAddMargin)).append("\n");
		sb.append("    positionAmount: ").append(toIndentedString(positionAmount)).append("\n");
		sb.append("    isolatedMargin: ").append(toIndentedString(isolatedMargin)).append("\n");
		sb.append("    leverage: ").append(toIndentedString(leverage)).append("\n");
		sb.append("    liquidationPrice: ").append(toIndentedString(liquidationPrice)).append("\n");
		sb.append("    markPrice: ").append(toIndentedString(markPrice)).append("\n");
		sb.append("    maxNotionalValue: ").append(toIndentedString(maxNotionalValue)).append("\n");
		sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
		sb.append("    unrealizedProfit: ").append(toIndentedString(unrealizedProfit)).append("\n");
		sb.append("    positionSide: ").append(toIndentedString(positionSide)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces
	 * (except the first line).
	 */
	private String toIndentedString(java.lang.Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

	public void writeToParcel(Parcel out, int flags) {
		out.writeValue(entryPrice);
		out.writeValue(marginType);
		out.writeValue(isAutoAddMargin);
		out.writeValue(positionAmount);
		out.writeValue(isolatedMargin);
		out.writeValue(leverage);
		out.writeValue(liquidationPrice);
		out.writeValue(markPrice);
		out.writeValue(maxNotionalValue);
		out.writeValue(symbol);
		out.writeValue(unrealizedProfit);
		out.writeValue(positionSide);
	}

	public int describeContents() {
		return 0;
	}
}
