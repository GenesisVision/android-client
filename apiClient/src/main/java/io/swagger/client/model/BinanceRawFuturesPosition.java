/*
 * Core API v2.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import android.os.Parcel;
import android.os.Parcelable;

import com.google.gson.annotations.SerializedName;

import java.util.Objects;

import io.swagger.v3.oas.annotations.media.Schema;

/**
 * BinanceRawFuturesPosition
 */


public class BinanceRawFuturesPosition implements Parcelable
{
	public static final Parcelable.Creator<BinanceRawFuturesPosition> CREATOR = new Parcelable.Creator<BinanceRawFuturesPosition>()
	{
		public BinanceRawFuturesPosition createFromParcel(Parcel in) {
			return new BinanceRawFuturesPosition(in);
		}

		public BinanceRawFuturesPosition[] newArray(int size) {
			return new BinanceRawFuturesPosition[size];
		}
	};

	@SerializedName("entryPrice")
	private Double entryPrice = null;

	@SerializedName("marginType")
	private BinanceFuturesMarginType marginType = null;

	@SerializedName("isAutoAddMargin")
	private Boolean isAutoAddMargin = null;

	@SerializedName("isolatedMargin")
	private Double isolatedMargin = null;

	@SerializedName("leverage")
	private Integer leverage = null;

	@SerializedName("liquidationPrice")
	private Double liquidationPrice = null;

	@SerializedName("markPrice")
	private Double markPrice = null;

	@SerializedName("symbol")
	private String symbol = null;

	@SerializedName("positionSide")
	private BinancePositionSide positionSide = null;

	@SerializedName("quantity")
	private Double quantity = null;

	@SerializedName("unrealizedPnL")
	private Double unrealizedPnL = null;

	@SerializedName("maxNotional")
	private Double maxNotional = null;

	public BinanceRawFuturesPosition() {
	}

	BinanceRawFuturesPosition(Parcel in) {
		entryPrice = (Double) in.readValue(null);
		marginType = (BinanceFuturesMarginType) in.readValue(BinanceFuturesMarginType.class.getClassLoader());
		isAutoAddMargin = (Boolean) in.readValue(null);
		isolatedMargin = (Double) in.readValue(null);
		leverage = (Integer) in.readValue(null);
		liquidationPrice = (Double) in.readValue(null);
		markPrice = (Double) in.readValue(null);
		symbol = (String) in.readValue(null);
		positionSide = (BinancePositionSide) in.readValue(BinancePositionSide.class.getClassLoader());
		quantity = (Double) in.readValue(null);
		unrealizedPnL = (Double) in.readValue(null);
		maxNotional = (Double) in.readValue(null);
	}

	public BinanceRawFuturesPosition entryPrice(Double entryPrice) {
		this.entryPrice = entryPrice;
		return this;
	}

	/**
	 * Get entryPrice
	 *
	 * @return entryPrice
	 **/
	@Schema(description = "")
	public Double getEntryPrice() {
		return entryPrice;
	}

	public void setEntryPrice(Double entryPrice) {
		this.entryPrice = entryPrice;
	}

	public BinanceRawFuturesPosition marginType(BinanceFuturesMarginType marginType) {
		this.marginType = marginType;
		return this;
	}

	/**
	 * Get marginType
	 *
	 * @return marginType
	 **/
	@Schema(description = "")
	public BinanceFuturesMarginType getMarginType() {
		return marginType;
	}

	public void setMarginType(BinanceFuturesMarginType marginType) {
		this.marginType = marginType;
	}

	public BinanceRawFuturesPosition isAutoAddMargin(Boolean isAutoAddMargin) {
		this.isAutoAddMargin = isAutoAddMargin;
		return this;
	}

	/**
	 * Get isAutoAddMargin
	 *
	 * @return isAutoAddMargin
	 **/
	@Schema(description = "")
	public Boolean isIsAutoAddMargin() {
		return isAutoAddMargin;
	}

	public void setIsAutoAddMargin(Boolean isAutoAddMargin) {
		this.isAutoAddMargin = isAutoAddMargin;
	}

	public BinanceRawFuturesPosition isolatedMargin(Double isolatedMargin) {
		this.isolatedMargin = isolatedMargin;
		return this;
	}

	/**
	 * Get isolatedMargin
	 *
	 * @return isolatedMargin
	 **/
	@Schema(description = "")
	public Double getIsolatedMargin() {
		return isolatedMargin;
	}

	public void setIsolatedMargin(Double isolatedMargin) {
		this.isolatedMargin = isolatedMargin;
	}

	public BinanceRawFuturesPosition leverage(Integer leverage) {
		this.leverage = leverage;
		return this;
	}

	/**
	 * Get leverage
	 *
	 * @return leverage
	 **/
	@Schema(description = "")
	public Integer getLeverage() {
		return leverage;
	}

	public void setLeverage(Integer leverage) {
		this.leverage = leverage;
	}

	public BinanceRawFuturesPosition liquidationPrice(Double liquidationPrice) {
		this.liquidationPrice = liquidationPrice;
		return this;
	}

	/**
	 * Get liquidationPrice
	 *
	 * @return liquidationPrice
	 **/
	@Schema(description = "")
	public Double getLiquidationPrice() {
		return liquidationPrice;
	}

	public void setLiquidationPrice(Double liquidationPrice) {
		this.liquidationPrice = liquidationPrice;
	}

	public BinanceRawFuturesPosition markPrice(Double markPrice) {
		this.markPrice = markPrice;
		return this;
	}

	/**
	 * Get markPrice
	 *
	 * @return markPrice
	 **/
	@Schema(description = "")
	public Double getMarkPrice() {
		return markPrice;
	}

	public void setMarkPrice(Double markPrice) {
		this.markPrice = markPrice;
	}

	public BinanceRawFuturesPosition symbol(String symbol) {
		this.symbol = symbol;
		return this;
	}

	/**
	 * Get symbol
	 *
	 * @return symbol
	 **/
	@Schema(description = "")
	public String getSymbol() {
		return symbol;
	}

	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}

	public BinanceRawFuturesPosition positionSide(BinancePositionSide positionSide) {
		this.positionSide = positionSide;
		return this;
	}

	/**
	 * Get positionSide
	 *
	 * @return positionSide
	 **/
	@Schema(description = "")
	public BinancePositionSide getPositionSide() {
		return positionSide;
	}

	public void setPositionSide(BinancePositionSide positionSide) {
		this.positionSide = positionSide;
	}

	public BinanceRawFuturesPosition quantity(Double quantity) {
		this.quantity = quantity;
		return this;
	}

	/**
	 * Get quantity
	 *
	 * @return quantity
	 **/
	@Schema(description = "")
	public Double getQuantity() {
		return quantity;
	}

	public void setQuantity(Double quantity) {
		this.quantity = quantity;
	}

	public BinanceRawFuturesPosition unrealizedPnL(Double unrealizedPnL) {
		this.unrealizedPnL = unrealizedPnL;
		return this;
	}

	/**
	 * Get unrealizedPnL
	 *
	 * @return unrealizedPnL
	 **/
	@Schema(description = "")
	public Double getUnrealizedPnL() {
		return unrealizedPnL;
	}

	public void setUnrealizedPnL(Double unrealizedPnL) {
		this.unrealizedPnL = unrealizedPnL;
	}

	public BinanceRawFuturesPosition maxNotional(Double maxNotional) {
		this.maxNotional = maxNotional;
		return this;
	}

	/**
	 * Get maxNotional
	 *
	 * @return maxNotional
	 **/
	@Schema(description = "")
	public Double getMaxNotional() {
		return maxNotional;
	}

	public void setMaxNotional(Double maxNotional) {
		this.maxNotional = maxNotional;
	}

	@Override
	public boolean equals(java.lang.Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		BinanceRawFuturesPosition binanceRawFuturesPosition = (BinanceRawFuturesPosition) o;
		return Objects.equals(this.entryPrice, binanceRawFuturesPosition.entryPrice) &&
				Objects.equals(this.marginType, binanceRawFuturesPosition.marginType) &&
				Objects.equals(this.isAutoAddMargin, binanceRawFuturesPosition.isAutoAddMargin) &&
				Objects.equals(this.isolatedMargin, binanceRawFuturesPosition.isolatedMargin) &&
				Objects.equals(this.leverage, binanceRawFuturesPosition.leverage) &&
				Objects.equals(this.liquidationPrice, binanceRawFuturesPosition.liquidationPrice) &&
				Objects.equals(this.markPrice, binanceRawFuturesPosition.markPrice) &&
				Objects.equals(this.symbol, binanceRawFuturesPosition.symbol) &&
				Objects.equals(this.positionSide, binanceRawFuturesPosition.positionSide) &&
				Objects.equals(this.quantity, binanceRawFuturesPosition.quantity) &&
				Objects.equals(this.unrealizedPnL, binanceRawFuturesPosition.unrealizedPnL) &&
				Objects.equals(this.maxNotional, binanceRawFuturesPosition.maxNotional);
	}

	@Override
	public int hashCode() {
		return Objects.hash(entryPrice, marginType, isAutoAddMargin, isolatedMargin, leverage, liquidationPrice, markPrice, symbol, positionSide, quantity, unrealizedPnL, maxNotional);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class BinanceRawFuturesPosition {\n");

		sb.append("    entryPrice: ").append(toIndentedString(entryPrice)).append("\n");
		sb.append("    marginType: ").append(toIndentedString(marginType)).append("\n");
		sb.append("    isAutoAddMargin: ").append(toIndentedString(isAutoAddMargin)).append("\n");
		sb.append("    isolatedMargin: ").append(toIndentedString(isolatedMargin)).append("\n");
		sb.append("    leverage: ").append(toIndentedString(leverage)).append("\n");
		sb.append("    liquidationPrice: ").append(toIndentedString(liquidationPrice)).append("\n");
		sb.append("    markPrice: ").append(toIndentedString(markPrice)).append("\n");
		sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
		sb.append("    positionSide: ").append(toIndentedString(positionSide)).append("\n");
		sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
		sb.append("    unrealizedPnL: ").append(toIndentedString(unrealizedPnL)).append("\n");
		sb.append("    maxNotional: ").append(toIndentedString(maxNotional)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces
	 * (except the first line).
	 */
	private String toIndentedString(java.lang.Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

	public void writeToParcel(Parcel out, int flags) {
		out.writeValue(entryPrice);
		out.writeValue(marginType);
		out.writeValue(isAutoAddMargin);
		out.writeValue(isolatedMargin);
		out.writeValue(leverage);
		out.writeValue(liquidationPrice);
		out.writeValue(markPrice);
		out.writeValue(symbol);
		out.writeValue(positionSide);
		out.writeValue(quantity);
		out.writeValue(unrealizedPnL);
		out.writeValue(maxNotional);
	}

	public int describeContents() {
		return 0;
	}
}
